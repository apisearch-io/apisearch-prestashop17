<?php

/*
 * This file is part of the Apisearch Server
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Feel free to edit as you please, and have fun.
 *
 * @author Marc Morera <yuhu@mmoreram.com>
 */

/**
 * Class ApisearchClient
 */
class ApisearchClient {

  /**
   * @var array
   *
   * Elements to update
   */
  private $elementstoPut;

  /**
   * @var array
   *
   * Elements to delete
   */
  private $elementsToDelete;

  /**
   * @var string
   *
   * Host
   */
  private $host;

  /**
   * @var string
   *
   * Version
   */
  private $version;

  /**
   * @var string
   *
   * App id
   */
  private $appUUID;

  /**
   * @var string
   *
   * Index id
   */
  private $indexUUID;

  /**
   * @var string
   *
   * Token
   */
  private $tokenUUID;

  /**
   * Set credentials.
   *
   * @param string $appUUID
   * @param string $indexUUID
   * @param string $tokenUUID
   */
  public function setCredentials(
          $appUUID,
          $indexUUID,
          $tokenUUID
  ) {
    $this->appUUID = $appUUID;
    $this->indexUUID = $indexUUID;
    $this->tokenUUID = $tokenUUID;
  }

  /**
   * Repository constructor.
   *
   * @param string $host
   * @param string $version
   */
  public function __construct(
          $host,
          $version
  ) {
    $this->resetCachedElements();
    $this->host = $host;
    $this->version = $version;
  }

  /**
   * Reset cache.
   */
  private function resetCachedElements() {
    $this->elementstoPut = [];
    $this->elementsToDelete = [];
  }

  /**
   * Search across the index types.
   *
   * @param array $query
   *
   * @return array
   *
   * @throws Exception
   */
  public function query(array $query) {
    return $this->get(
                    '/{{app_uuid}}',
                    'get',
                    ['query' => json_encode($query)]
    );
  }

  /**
   * Reset index.
   *
   * @throws Exception
   */
  public function resetIndex() {
    $this->get(
            '/{{app_uuid}}/indices/{{index_uuid}}/reset',
            'POST'
    );
  }

  /**
   * Put item.
   *
   * @param array $item
   */
  public function putItem(array $item) {
    $itemUUID = $this->composeUUID($item['uuid']);

    $this->elementstoPut[$itemUUID] = $item;
    unset($this->elementsToDelete[$itemUUID]);
  }

  /**
   * Generate item documents.
   *
   * @param array[] $items
   */
  public function putItems(array $items) {
    foreach ($items as $item) {
      $this->putItem($item);
    }
  }

  /**
   * Delete item documents by uuid.
   *
   * @param array[] $uuids
   */
  public function deleteItems(array $uuids) {
    foreach ($uuids as $uuid) {
      $this->deleteItem($uuid);
    }
  }

  /**
   * Delete item document by uuid.
   *
   * @param array $uuid
   */
  public function deleteItem(array $uuid) {
    $itemUUID = $this->composeUUID($uuid);
    $this->elementsToDelete[$itemUUID] = $uuid;
    unset($this->elementstoPut[$itemUUID]);
  }

  /**
   * Delete items by query
   *
   * @param array $query
   */
  public function deleteItemsByQuery(array $query) {
    return $this->get(
                    '/{{app_uuid}}/indices/{{index_uuid}}/items/by-query',
                    'delete',
                    [],
                    $query
    );
  }

  /**
   * Flush all.
   *
   * This flush can be avoided if not enough items have been generated by
   * setting $skipIfLess = true
   *
   * @param int  $bulkNumber
   * @param bool $skipIfLess
   *
   * @throws Exception
   */
  public function flush(
          $bulkNumber = 100,
          $skipIfLess = false
  ) {
    if (
            $skipIfLess &&
            count($this->elementstoPut) < $bulkNumber
    ) {
      return;
    }

    $offset = 0;

    try {
      while (true) {
        $items = array_slice(
                $this->elementstoPut,
                $offset,
                $bulkNumber
        );

        if (empty($items)) {
          break;
        }

        $this->flushItems($items, []);
        $offset += $bulkNumber;
      }

      $this->flushItems([], $this->elementsToDelete);
    } catch (Exception $exception) {
      /*
       * No matter the exception is thrown, cached elements should be
       * deleted
       */
      $this->resetCachedElements();

      throw $exception;
    }

    $this->resetCachedElements();
  }

  /**
   * Flush items.
   *
   * @param array[] $itemstoPut
   * @param array[] $itemsToDelete
   *
   * @throws Exception
   */
  private function flushItems(
          array $itemstoPut,
          array $itemsToDelete
  ) {
    if (!empty($itemstoPut)) {
      $this->get(
              '/{{app_uuid}}/indices/{{index_uuid}}/items',
              'put',
              [],
              array_values($itemstoPut)
      );
    }

    if (!empty($itemsToDelete)) {
      $this->get(
              '/{{app_uuid}}/indices/{{index_uuid}}/items',
              'delete',
              [],
              array_values($itemsToDelete)
      );
    }
  }

  /**
   * Compose unique id.
   *
   * @param array $itemUUID
   *
   * @return string
   */
  private function composeUUID(array $itemUUID) {
    return $itemUUID['id'] . '~' . $itemUUID['type'];
  }

  /**
   * Make a request and return response.
   *
   * @param string $endpoint
   * @param string $method
   * @param array  $parameters
   * @param array  $body
   *
   * @return string
   *
   * @throws Exception
   */
  private function get(
          $endpoint,
          $method,
          array $parameters = [],
          array $body = []
  ) {
    $endpoint = str_replace([
        '{{app_uuid}}',
        '{{index_uuid}}',
        '{{token_uuid}}',
            ], [
        $this->appUUID,
        $this->indexUUID,
        $this->tokenUUID,
            ], $endpoint);

    $url = sprintf('%s/%s/%s?token=%s',
            rtrim($this->host, '/'),
            trim($this->version, '/'),
            ltrim($endpoint, '/'),
            $this->tokenUUID
    );

    $parameters = array_map('urlencode', $parameters);
    foreach ($parameters as $parameterKey => $parameterValue) {
      $url .= "&$parameterKey=$parameterValue";
    }

    if ('get' !== $method) {
      $data = json_encode($body, JSON_PRESERVE_ZERO_FRACTION);
      
      $ch = curl_init();
      curl_setopt($ch, CURLOPT_URL, $url);
      curl_setopt($ch, CURLOPT_HTTPHEADER, array("Content-type: application/json", "Accept: application/json", "Connection: close", "Content-length: ".strlen($data)));
      curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);
      curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
      curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
      $data = curl_exec($ch);
      $response = curl_exec($ch);
      $err = curl_error($ch);
      curl_close($ch);
    } else {
      $ch = curl_init();
      curl_setopt($ch, CURLOPT_URL, $url);
      curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);
      curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
      $data = curl_exec($ch);
      $response = curl_exec($ch);
      $err = curl_error($ch);
      curl_close($ch);
    }
    
    if ($err) {
      throw new Exception($err);
      return;
    }

    return json_decode($response, true);
  }

  /**
   * Parse response header and return value.
   *
   * @param string $header
   *
   * @return int
   */
  private function parseResponseStatusCode($header) {
    try {
      list(, $code, $status) = explode(' ', $header, 3);

      return (int) $code;
    } catch (Exception $exception) {
      // Silent pass
    }

    return null;
  }

  public function getUsage() {
    return $this->get(
                    '/{{app_uuid}}/usage',
                    'GET'
    );
  }

}
